import streamlit as st
import pandas as pd
import joblib
import pefile
import io
import tempfile
import os 

# Load the pre-trained model
loaded_model = joblib.load('random_forest_model.pkl')


import streamlit as st
import pefile

def extract_parameters(uploaded_file):
    # Save the uploaded file to a temporary location
    with open("temp_file.exe", "wb") as f:
        f.write(uploaded_file.getbuffer())

    # Open the temporary file with pefile
    pe = pefile.PE("temp_file.exe")

    # Extract relevant parameters
    parameters = {
        'SizeOfOptionalHeader': pe.FILE_HEADER.SizeOfOptionalHeader,
        'Characteristics': pe.FILE_HEADER.Characteristics,
        'MajorLinkerVersion': getattr(pe.OPTIONAL_HEADER, 'MajorLinkerVersion', None),
        'MinorLinkerVersion': getattr(pe.OPTIONAL_HEADER, 'MinorLinkerVersion', None),
        'SizeOfCode': getattr(pe.OPTIONAL_HEADER, 'SizeOfCode', None),
        'SizeOfInitializedData': getattr(pe.OPTIONAL_HEADER, 'SizeOfInitializedData', None),
        'SizeOfUninitializedData': getattr(pe.OPTIONAL_HEADER, 'SizeOfUninitializedData', None),
        'AddressOfEntryPoint': getattr(pe.OPTIONAL_HEADER, 'AddressOfEntryPoint', None),
        'BaseOfCode': getattr(pe.OPTIONAL_HEADER, 'BaseOfCode', None),
        'BaseOfData': getattr(pe.OPTIONAL_HEADER, 'BaseOfData', None),
        'ImageBase': getattr(pe.OPTIONAL_HEADER, 'ImageBase', None),
        'SectionAlignment': getattr(pe.OPTIONAL_HEADER, 'SectionAlignment', None),
        'FileAlignment': getattr(pe.OPTIONAL_HEADER, 'FileAlignment', None),
        'MajorOperatingSystemVersion': getattr(pe.OPTIONAL_HEADER, 'MajorOperatingSystemVersion', None),
        'MinorOperatingSystemVersion': getattr(pe.OPTIONAL_HEADER, 'MinorOperatingSystemVersion', None),
        'MajorImageVersion': getattr(pe.OPTIONAL_HEADER, 'MajorImageVersion', None),
        'MinorImageVersion': getattr(pe.OPTIONAL_HEADER, 'MinorImageVersion', None),
        'MajorSubsystemVersion': getattr(pe.OPTIONAL_HEADER, 'MajorSubsystemVersion', None),
        'MinorSubsystemVersion': getattr(pe.OPTIONAL_HEADER, 'MinorSubsystemVersion', None),
        'SizeOfImage': getattr(pe.OPTIONAL_HEADER, 'SizeOfImage', None),
        'SizeOfHeaders': getattr(pe.OPTIONAL_HEADER, 'SizeOfHeaders', None),
        'CheckSum': getattr(pe.OPTIONAL_HEADER, 'CheckSum', None),
        'Subsystem': getattr(pe.OPTIONAL_HEADER, 'Subsystem', None),
        'DllCharacteristics': getattr(pe.OPTIONAL_HEADER, 'DllCharacteristics', None),
        'SizeOfStackReserve': getattr(pe.OPTIONAL_HEADER, 'SizeOfStackReserve', None),
        'SizeOfStackCommit': getattr(pe.OPTIONAL_HEADER, 'SizeOfStackCommit', None),
        'SizeOfHeapReserve': getattr(pe.OPTIONAL_HEADER, 'SizeOfHeapReserve', None),
        'SizeOfHeapCommit': getattr(pe.OPTIONAL_HEADER, 'SizeOfHeapCommit', None),
        'LoaderFlags': getattr(pe.OPTIONAL_HEADER, 'LoaderFlags', None),
        'NumberOfRvaAndSizes': getattr(pe.OPTIONAL_HEADER, 'NumberOfRvaAndSizes', None),
        'SectionsNb': len(pe.sections),
    }

    # Close the PE file
    pe.close()

    # Delete the temporary file
    os.unlink("temp_file.exe")

    return parameters


# Define the feature names used during training
feature_names = [
    'SizeOfOptionalHeader', 'Characteristics', 'MajorLinkerVersion', 'MinorLinkerVersion',
    'SizeOfCode', 'SizeOfInitializedData', 'SizeOfUninitializedData', 'AddressOfEntryPoint',
    'BaseOfCode', 'BaseOfData', 'ImageBase', 'SectionAlignment', 'FileAlignment',
    'MajorOperatingSystemVersion', 'MinorOperatingSystemVersion', 'MajorImageVersion',
    'MinorImageVersion', 'MajorSubsystemVersion', 'MinorSubsystemVersion', 'SizeOfImage',
    'SizeOfHeaders', 'CheckSum', 'Subsystem', 'DllCharacteristics', 'SizeOfStackReserve',
    'SizeOfStackCommit', 'SizeOfHeapReserve', 'SizeOfHeapCommit', 'LoaderFlags',
    'NumberOfRvaAndSizes', 'SectionsNb', 'SectionsMeanEntropy', 'SectionsMinEntropy',
    'SectionsMaxEntropy', 'SectionsMeanRawsize', 'SectionsMinRawsize', 'SectionMaxRawsize',
    'SectionsMeanVirtualsize', 'SectionsMinVirtualsize', 'SectionMaxVirtualsize',
    'ImportsNbDLL', 'ImportsNb', 'ImportsNbOrdinal', 'ExportNb', 'ResourcesNb',
    'ResourcesMeanEntropy', 'ResourcesMinEntropy', 'ResourcesMaxEntropy',
    'ResourcesMeanSize', 'ResourcesMinSize', 'ResourcesMaxSize', 'LoadConfigurationSize',
    'VersionInformationSize', 'Machine_332', 'Machine_512', 'Machine_34404'
]




# Create the UI
st.title('Malware Detection')

# Upload file
uploaded_file = st.file_uploader("Upload a file", type=['exe'])

if uploaded_file is not None:
    # Display file details
    st.write("Uploaded file:", uploaded_file.name)
    
    # Extract parameters
    parameters = extract_parameters(uploaded_file)
    
    # Display extracted parameters
    st.write("Extracted parameters:")
    st.write(pd.DataFrame(parameters, index=[0]))
    
    # Prepare the extracted parameters for prediction
    sample_df = pd.DataFrame([parameters], columns=feature_names)
    
    # Make prediction
    prediction = loaded_model.predict(sample_df)
    
    # Display prediction
    if prediction[0] == 0:
        st.write("Prediction: Legitimate")
    else:
        st.write("Prediction: Malicious")
